#!/usr/bin/env node
/**
 * Automated Performance Benchmarks
 * Tests FPS, load time, and memory usage
 * Fails CI if performance regresses >10% from baseline
 * 
 * Usage:
 *   npm run performance-benchmark
 *   CI: Automatically runs on PR and push to main
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath, pathToFileURL } from 'url'
import { dirname } from 'path'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

// Baseline performance metrics (established from initial runs)
const BASELINE_METRICS = {
  fps: 60, // Target: 60 FPS
  loadTime: 3000, // Target: <3s initial load
  memoryUsage: 200, // Target: <200MB peak memory
  bundleSize: {
    index: 400 * 1024, // 400KB
    'react-vendor': 250 * 1024, // 250KB
    'three-vendor': 250 * 1024, // 250KB
    'network-vendor': 150 * 1024 // 150KB
  }
}

// Performance regression threshold: 10%
const REGRESSION_THRESHOLD = 0.10

/**
 * Read performance metrics from file (generated by performance profiler)
 */
function readPerformanceMetrics(metricsPath) {
  try {
    if (!fs.existsSync(metricsPath)) {
      console.error(`‚ùå Metrics file not found: ${metricsPath}`)
      return null
    }
    const data = fs.readFileSync(metricsPath, 'utf8')
    return JSON.parse(data)
  } catch (error) {
    console.error(`‚ùå Failed to read metrics: ${error.message}`)
    return null
  }
}

/**
 * Check bundle sizes from build output
 */
function checkBundleSizes(buildDir) {
  const distPath = path.join(process.cwd(), buildDir || 'dist')
  const bundleSizes = {}
  const errors = []
  const warnings = []

  if (!fs.existsSync(distPath)) {
    console.error(`‚ùå Build directory not found: ${distPath}`)
    return { bundleSizes, errors, warnings }
  }

  // Check main bundle
  const indexJs = path.join(distPath, 'index.html')
  if (fs.existsSync(indexJs)) {
    // Read index.html to find chunk references
    const html = fs.readFileSync(indexJs, 'utf8')
    const chunkMatches = html.match(/<script[^>]+src="([^"]+\.js)"/g) || []
    
    for (const match of chunkMatches) {
      const srcMatch = match.match(/src="([^"]+)"/)
      if (srcMatch) {
        const chunkPath = path.join(distPath, srcMatch[1].replace(/^\//, ''))
        if (fs.existsSync(chunkPath)) {
          const stats = fs.statSync(chunkPath)
          const name = path.basename(chunkPath, '.js')
          bundleSizes[name] = stats.size
        }
      }
    }
  }

  // Check for known chunks
  const knownChunks = ['index', 'react-vendor', 'three-vendor', 'network-vendor']
  for (const chunk of knownChunks) {
    const chunkFiles = [
      path.join(distPath, `${chunk}-${getHash()}.js`),
      path.join(distPath, `${chunk}.js`)
    ]
    
    for (const chunkFile of chunkFiles) {
      if (fs.existsSync(chunkFile)) {
        const stats = fs.statSync(chunkFile)
        bundleSizes[chunk] = stats.size
        break
      }
    }

    const baseline = BASELINE_METRICS.bundleSize[chunk]
    if (baseline && bundleSizes[chunk]) {
      const size = bundleSizes[chunk]
      const regression = (size - baseline) / baseline
      
      if (regression > REGRESSION_THRESHOLD) {
        errors.push(
          `‚ùå Bundle size regression: ${chunk} is ${(size / 1024).toFixed(2)}KB ` +
          `(${((size - baseline) / 1024).toFixed(2)}KB over baseline, ` +
          `${(regression * 100).toFixed(1)}% regression)`
        )
      } else if (regression > REGRESSION_THRESHOLD * 0.8) {
        warnings.push(
          `‚ö†Ô∏è  Bundle size warning: ${chunk} is ${(size / 1024).toFixed(2)}KB ` +
          `(${(regression * 100).toFixed(1)}% increase)`
        )
      }
    }
  }

  return { bundleSizes, errors, warnings }
}

/**
 * Generate hash for chunk files (simplified)
 */
function getHash() {
  return 'abc123' // In real scenario, would extract from actual build
}

/**
 * Run performance benchmarks
 */
function runBenchmarks() {
  console.log('üöÄ Running Performance Benchmarks\n')
  console.log('Baseline Metrics:')
  console.log(`  FPS: ${BASELINE_METRICS.fps}`)
  console.log(`  Load Time: ${BASELINE_METRICS.loadTime}ms`)
  console.log(`  Memory Usage: ${BASELINE_METRICS.memoryUsage}MB\n`)

  const errors = []
  const warnings = []

  // Check bundle sizes
  console.log('üì¶ Checking bundle sizes...')
  const { bundleSizes, errors: bundleErrors, warnings: bundleWarnings } = checkBundleSizes()
  errors.push(...bundleErrors)
  warnings.push(...bundleWarnings)

  if (Object.keys(bundleSizes).length > 0) {
    console.log('Bundle Sizes:')
    for (const [name, size] of Object.entries(bundleSizes)) {
      const sizeKB = (size / 1024).toFixed(2)
      console.log(`  ${name}: ${sizeKB}KB`)
    }
  }

  // In real scenario, would also:
  // 1. Run browser-based performance tests (using Playwright/Puppeteer)
  // 2. Measure FPS during gameplay
  // 3. Measure memory usage over time
  // 4. Measure initial load time

  // Output results
  console.log('\nüìä Benchmark Results:')
  if (warnings.length > 0) {
    console.log('\n‚ö†Ô∏è  Warnings:')
    warnings.forEach(w => console.log(`  ${w}`))
  }

  if (errors.length > 0) {
    console.log('\n‚ùå Errors:')
    errors.forEach(e => console.log(`  ${e}`))
    console.log('\n‚ùå Performance benchmarks failed!')
    if (process.env.CI === 'true') {
      process.exit(1)
    }
  } else {
    console.log('\n‚úÖ All performance benchmarks passed!')
  }

  return { errors, warnings, bundleSizes }
}

// Export for use in CI/CD
// Check if this file is being run directly (not imported)
const isMainModule = import.meta.url === pathToFileURL(process.argv[1]).href || 
                      process.argv[1]?.endsWith('benchmarks.js')
if (isMainModule) {
  runBenchmarks()
}

export { runBenchmarks, BASELINE_METRICS, REGRESSION_THRESHOLD }

